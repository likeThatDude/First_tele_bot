import re
from datetime import datetime


async def check_user_date(user_date):
    """
        Проверяет допустимость диапазона дат, предоставленных пользователем, и возвращает
        отформатированные даты начала и конца.

        Функция проверяет, соответствует ли входная строка `user_date` формату "ДД/ММ/ГГГГ-ДД/ММ/ГГГГ",
        где "ДД" - день, "ММ" - месяц, а "ГГГГ" - год. Затем проверяет начальную и конечную даты,
        чтобы убедиться, что они не являются прошлыми, что дата начала не идет после даты окончания,
        и что обе даты имеют допустимые значения дней для своих месяцев. Функция также учитывает
        високосные годы (когда в феврале 29 дней).

        Параметры:
            user_date (str): Строка с диапазоном дат, предоставленным пользователем, в формате "ДД/ММ/ГГГГ-ДД/ММ/ГГГГ".

        Возвращает:
            list[str, str] или False: Если входная строка `user_date` является допустимой, функция возвращает список,
            содержащий отформатированную дату начала и дату окончания в виде строк в формате "ГГГГ-ММ-ДД".
            В противном случае возвращается значение False.

        Пример:
            Вход: "15/07/2023-25/07/2023"
            Выход: ['2023-07-15', '2023-07-25']

            Вход: "30/06/2022-05/07/2022"
            Выход: ['2022-06-30', '2022-07-05']

            Вход: "10/03/2023-05/03/2023"
            Выход: False

        Примечание:
            - Дата начала и дата окончания должны быть больше или равны текущей дате.
            - Дата начала не должна идти после даты окончания.
            - День каждой даты должен быть допустимым для соответствующего месяца.
            - Учитываются високосные годы для февраля.
        """
    date_pattern = re.compile(
        '^(0[1-9]|[1-2]\d|3[0-1])\/(0[1-9]|1[0-2])\/\d{4}-(0[1-9]|[1-2]\d|3[0-1])\/(0[1-9]|1[0-2])\/\d{4}$')

    if not date_pattern.match(user_date):
        return False

    date_parts = user_date.split('-')
    start_date_str, end_date_str = date_parts[0], date_parts[1]

    start_date = datetime.strptime(start_date_str, '%d/%m/%Y').date()
    end_date = datetime.strptime(end_date_str, '%d/%m/%Y').date()

    # Удаление времени из текущей даты
    current_date = datetime.now().date()

    # Проверка на будущую дату (начальная и конечная дата должны быть больше или равны текущей дате)
    if start_date < current_date or end_date < current_date:
        return False

    if start_date > end_date:
        return False

    days_in_month = {
        1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30,
        7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31
    }

    # Проверка на високосный год (29 дней в феврале)
    if start_date.year % 4 == 0 and (start_date.year % 100 != 0 or start_date.year % 400 == 0):
        days_in_month[2] = 29

    if start_date.day > days_in_month[start_date.month] or end_date.day > days_in_month[end_date.month]:
        return False

    # Возвращаем даты в формате "00-00-0000"
    start_date_formatted = start_date.strftime('%Y-%m-%d')
    end_date_formatted = end_date.strftime('%Y-%m-%d')

    return [start_date_formatted, end_date_formatted]
